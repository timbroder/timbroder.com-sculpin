<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[timbroder.com]]></title>
    <link href="https://www.timbroder.com/blog/tags/CoreData.xml" rel="self"/>
    <link href="https://www.timbroder.com/"/>
    <updated>2018-09-09T12:21:33+00:00</updated>
    <id>https://www.timbroder.com/</id>
            <author>
            <name><![CDATA[Tim Broder]]></name>            <email><![CDATA[timothy.broder@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Reordering a NSFetchedResultsController]]></title>
            <link href="https://www.timbroder.com/2014/05/reordering-nsfetchedresultscontroller.html"/>
            <updated>2014-05-31T16:14:22+00:00</updated>
            <id>https://www.timbroder.com/2014/05/reordering-nsfetchedresultscontroller.html</id>
            <content type="html"><![CDATA[<p>I’m working with a NSFetchedResultsController backed UITableView.  Up until
now I’ve just been ordering the items by the time they were added.</p>

<p>I’m moving on to Delete and Edit.  Editing the content itself isn’t needed,
once an item is added to this list, it can’t be changed. Deleting is
straightforward in</p>

<pre><code data-language="c">(void)controller:(NSFetchedResultsController *)controller
didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath
forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath
*)newIndexPath {
</code></pre>

<p>With reordering, I have a conundrum.  I have an
<a href="http://stackoverflow.com/a/2013070/647343">approach</a> for the actual re-order
that will have the View and the data playing nice. But, now I need to persist
the order.  I don’t have a property in Core Data for this (yet).  I’m trying
to figure out what to set this property to. The brute force approach is to use
the indexPath of the cell.  I have concerns with this.  Adding an item
automatically puts it at the top of the list. This would give it an index of 0
(I only have 1 section).  But, then I would have to update the order property
of every other item in the list. The same goes for moving: each item and every
item in between (I can luckily skip the outer bounds) will have to be updated.
I don’t like this. There has to be a better way, I just need to figure it out.</p>

<p>Some kind of indexPath+hash? indexPath+integer?</p>

<p>Eventually I’ll reach a list size where I run into performance problems with
the brute force approach. The cop out would be to limit the size of the list.
I don’t want to do that either.  I don’t know if I’ll go to the extreme of
Brent Simmons’ data set of <a href="http://inessential.com/2013/10/05/vesper_sync_diary_2_core_data">30,000 items from Daring Fireball’s
archive</a>, but
I want to shoot for that.</p>

<p>I’ll update this post with my progress</p>

<p><strong>Update</strong> 2014-05-31 01:02 PM</p>

<p><a href="http://stackoverflow.com/a/1648504">This</a> is a great starting point for
dealing with reordering. I was on the right track with only dealing with the
differences between items that get moved.  Dragging an item way down on a list
may(?) not happen much, it’s annoying to do. I think I’m going with that
assumption for now.  I still don’t feel great about the number of updates for
an insert…</p>

<p>Batch fetch/update/save is my starting point</p>

<p><strong>Update</strong> 2014-06-06 04:04 PM</p>

<p>It looks like iOS 8 might have better bulk update support. Downloading <a href="http://devstreaming.apple.com/videos/wwdc/2014/225xxgzhqylosff/225/225_hd_whats_new_in_core_data.mov?dl=1">this</a> session now</p>

<blockquote>
  <p><a href="https://twitter.com/inessential">@inessential</a>
  <a href="https://twitter.com/brentsimmons">@brentsimmons</a> You might like the Core Data
  video. new NSBatchUpdateRequest api with a “mark all as read” example as the
  demo</p>
</blockquote>

<p>></p>

<blockquote>
  <p>-- solsberg (@solsberg) <a href="https://twitter.com/solsberg/statuses/474993780186447872">June 6,
  2014</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[AVSpeechSynthesizer&#039;s queue doesn&#039;t work]]></title>
            <link href="https://www.timbroder.com/2014/03/avspeechsynthesizers-queue-doesnt-work.html"/>
            <updated>2014-03-01T20:46:39+00:00</updated>
            <id>https://www.timbroder.com/2014/03/avspeechsynthesizers-queue-doesnt-work.html</id>
            <content type="html"><![CDATA[<p>Sort of. It acts as a queue, but subsequent items have problems. Taken from
the <a href="https://developer.apple.com/library/ios/documentation/AVFoundation/Reference/AVSpeechSynthesizer_Ref/Reference/Reference.html#//apple_ref/occ/instm/AVSpeechSynthesizer/speakUtterance:" title="documentation">documentation</a> of <code>- (void)speakUtterance:(AVSpeechUtterance *)_utterance_</code></p>

<blockquote>
  <p>Calling this method adds the utterance to a <strong>queue; utterances are spoken
  in the order in which they are added to the queue</strong>. If the synthesizer is not
  currently speaking, the utterance is spoken immediately.</p>
</blockquote>

<p>This is true. You can queue up as many AVSpeechUtterance objects as you want,
and they will be spoken, in order.  The problem is if you try to act on the
Synthesizer after the first Utterance has been spoken. Specifically, I'm
having an issue with pausing. But, stopping has an issue as well. If I try to
pause during the first utterance using
pauseSpeakingAtBoundary:AVSpeechBoundaryImmediate, I get the expected
behavior. The speech stops and I can start it again with continueSpeaking.
(Even on the first Utterance, AVSpeechBoundaryWord, is giving me issues so I'm
putting that aside for now). However, if I try to pause on any of the
subsequent Utterances, nothing happens.  The pausedSpeaking call is ignored.
(The synthesizer isn't nil, I checked). So, why am I queuing up a lot of text?
I plan on having AVSpeechSynthesizer speak a lot of text. This text is stored
in CoreData.  Let's say my main object is called Read. Instead of storing all
of the text for that object in Read.text I've split out the text into slices,
stored in a separate Text entity. A Read object can have many of these.  This
gives me control over how much text I load into memory at once.  My original
plan was to load each slice into an Utterance.  When the speaking was done for
that Utternace, queue up the next one (it should start immediatly or close to
it). Fragments of this below:</p>

<pre><code data-language="C">    self.speechSynthesizer = [AVSpeechSynthesizer new];
    self.speechSynthesizer.delegate = self;

- (BOOL)addWordsToQueue:(NSString *)words
{
    if ( !words ) {
        return NO;
    }

    AVSpeechUtterance *utterance = [AVSpeechUtterance speechUtteranceWithString:words];
    utterance.rate = AVSpeechUtteranceMinimumSpeechRate;
    [self.speechSynthesizer speakUtterance:utterance];

    return YES;
}

//used in view
- (void)play
{
    [self.speechSynthesizer continueSpeaking];
}

- (void)pause
{
    [self.speechSynthesizer pauseSpeakingAtBoundary:AVSpeechBoundaryImmediate];
}

- (BOOL)isPaused
{
    return self.speechSynthesizer.isPaused;
}

#pragma mark - AVSpeechSynthesizerDelegate

- (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didFinishSpeechUtterance:(AVSpeechUtterance *)utterance
{
    NSString *words = [read getAndIncrementCurrentWordsAsString];

    if ( words != nil ) {
        [self addWordsToQueue:words];
    }
}
</code></pre>

<p>Again, the first Utterance
works fine, the rest don't. I've also experimented with queueing multiple
slices at once, as well as checking if the synthesizer I get in
didFinishSpeechUtterance is the correct instance.</p>

<p>I'm
<a href="http://stackoverflow.com/questions/19672814/an-issue-with-avspeechsynthesizer-any-workarounds">not</a> the first person to run into this issue.
There are also a number of
<a href="http://openradar.appspot.com/search?query=AVSpeechSynthesizer+">radars</a>. I've
added one as well.</p>

<p>There is a workaround, but it's dirty and shouldn't be
needed. In didFinishSpeechUtterance I recreate my AVSpeechSynthesizer so I'm
always dealing with the first item in the queue. I really don't like it.  This
is still broken in 7.1 beta 5. Hopefully it gets fixed. I'd like to implement
this properly.</p>

<pre><code data-language="C">- (void) resetSynth
{
    self.speechSynthesizer = [AVSpeechSynthesizer new];
    self.speechSynthesizer.delegate = self;
}

#pragma mark - AVSpeechSynthesizerDelegate

- (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didFinishSpeechUtterance:(AVSpeechUtterance *)utterance
{
    [self resetSynth];
    NSString *words = [read getAndIncrementCurrentWordsAsString];

    if ( words != nil ) {
        [self addWordsToQueue:words];
    }
}
</code></pre>

<p>This unfortunately still
happens in the 7.1 beta</p>
]]></content>
        </entry>
    </feed>