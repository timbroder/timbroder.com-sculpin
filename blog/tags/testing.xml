<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[timbroder.com]]></title>
    <link href="https://www.timbroder.com/blog/tags/testing.xml" rel="self"/>
    <link href="https://www.timbroder.com/"/>
    <updated>2018-09-09T12:21:33+00:00</updated>
    <id>https://www.timbroder.com/</id>
            <author>
            <name><![CDATA[Tim Broder]]></name>            <email><![CDATA[timothy.broder@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Setup and Teardown the Database Once Per Test Suite in PHPUnit]]></title>
            <link href="https://www.timbroder.com/2016/05/Setup-and-Teardown-the-Database-Once-Per-Test-Suite-with-PHPUnit-Listeners.html"/>
            <updated>2016-05-04T16:15:00+00:00</updated>
            <id>https://www.timbroder.com/2016/05/Setup-and-Teardown-the-Database-Once-Per-Test-Suite-with-PHPUnit-Listeners.html</id>
            <content type="html"><![CDATA[<p>I'm working on a series of integration tests where I want to set up and reset the database for each run. This could easily be done in the setUp and tearDown methods, but doing the full db each time is slow. Yes, I could just do the tables I need, but I was curious, and now I don't have to worry about which tables are setup in my testing DB. In this example, I'm using Laravel's migrations and SQLite as the test DB.</p>

<p><strong>UPDATE 05/05/2016</strong>: As Sebastian <a href="http://www.timbroder.com/2016/05/Setup-and-Teardown-the-Database-Once-Per-Test-Suite-with-PHPUnit-Listeners.html#comment-2659950789" title="point out below">points out below</a> (thanks!) there is a much more appropriate way. Using <code>setUpBeforeClass</code> and <code>tearDownAfterClass</code> we achieve the same effect</p>

<pre><code data-language="php">public static function setUpBeforeClass()
{
    parent::setUpBeforeClass();
    exec('php artisan migrate --database sqlite_test');
}

public static function tearDownAfterClass()
{
    exec('php artisan migrate:reset --database sqlite_test');
    parent::tearDownAfterClass(); 
}
</code></pre>

<p><del>PHPUnit has <a href="https://phpunit.de/manual/current/en/extending-phpunit.html#extending-phpunit.examples.SimpleTestListener.php" title="listeners">listeners</a> that you can tap into at various parts of your tests' lifecycle. I'm particularly interested in when a specific suite starts and ends. We'll need to do 2 things:</del></p>

<ol>
<li><del>Create our Listener</del></li>
<li><del>Register this Listener in phpunit.xml</del></li>
</ol>

<p>The listener is as follows:</p>

<pre><code data-language="php">class FullDBListener extends PHPUnit_Framework_BaseTestListener
{
    protected $suites = ['UserIntegrationTest', 'AccountIntegrationTest'];

    public function startTestSuite(PHPUnit_Framework_TestSuite $suite)
    {
        if (in_array($suite-&gt;getName(), $this-&gt;suites)) {
            exec('php artisan migrate --database sqlite_test');
        }
    }

    public function endTestSuite(PHPUnit_Framework_TestSuite $suite)
    {
        if (in_array($suite-&gt;getName(), $this-&gt;suites)) {
            exec('php artisan migrate:reset --database sqlite_test');
        }
    }
}
</code></pre>

<p>This does a few things:</p>

<ol>
<li><del>Stores the class names of each suite we want to run the db migrations for</del></li>
<li><del>In <code>startTestSuite</code> it checks to see if we're in the right suite</del></li>
<li><del>If we are, run an artisan migration on our test db</del></li>
<li><del>In <code>endTestSuite</code> it checks to see if we're in the right suite</del></li>
<li><del>If we are, run an artisan migration:reset on our test db</del></li>
</ol>

<p><del>Next, we need to make PHPUnit aware of this listener. Update your path accordingly</del></p>

<pre><code data-language="xml">&lt;listeners&gt;
    &lt;listener class="FullDBListener" file="./tests/app/FullDBListener.php"&gt;&lt;/listener&gt;
&lt;/listeners&gt;
</code></pre>

<p>That's it!</p>

<p>I do do some basic teardown in my test suite's <code>setUp</code> method to give me a blank slate. This has proven faster then doing the migrations each time</p>

<pre><code data-language="php">public function setUp()
{
    parent::setUp();

    User::truncate();
}
</code></pre>

<p>I hope this helped you, if you have any questions, let me know!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Trying to Mock a Self Booting Laravel Model Trait]]></title>
            <link href="https://www.timbroder.com/2016/04/Trying-to-Mock-a-Self-Booting-Laravel-Model-Trait.html"/>
            <updated>2016-04-12T11:01:00+00:00</updated>
            <id>https://www.timbroder.com/2016/04/Trying-to-Mock-a-Self-Booting-Laravel-Model-Trait.html</id>
            <content type="html"><![CDATA[<p><a href="http://www.archybold.com/blog/post/booting-eloquent-model-traits" title="Bootable">Bootable</a> Model traits are pretty nifty. I'm using them to register certain events for the models using my Trait. However, I've run into an issue trying to mock models that are using the trait. Specifically, when a Mockery version of the model is instantiated, it's boot code agrees that it should have a bootMyTrait method, but can't find it when it tries to call it.</p>

<p><a href="https://github.com/timbroder/mock-bootable-laravel-model-trait" title="Sample Repository">Sample Repository</a> for the below, with commands to reproduce.</p>

<p>As an example, here is a trait:</p>

<pre><code data-language="php">namespace App;
trait MyTrait
{
    public static function bootMyTrait()
    {
        print("Booting MyTrait\n");
    }
}
</code></pre>

<p>And a model using it:</p>

<pre><code data-language="php">namespace App;
use Illuminate\Database\Eloquent\Model;
class MyModel extends Model
{
    use MyTrait;
}
</code></pre>

<p>Instantiating the model regularly works fine. This shows the desired output:</p>

<pre><code data-language="php">$model = new MyModel();
</code></pre>

<p>However, trying to mock this model does not cooperate. This:</p>

<pre><code data-language="php">use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Foundation\Testing\DatabaseTransactions;


class ExampleTest extends TestCase
{
    /**
     * A basic functional test example.
     *
     * @return void
     */
    public function testTraitBooting()
    {
        $model = $this-&gt;getMock('App\MyModel');
    }
}
</code></pre>

<p>Fails. Adding some debugging to Eloquent:</p>

<pre><code data-language="php">    /**
     * Boot all of the bootable traits on the model.
     *
     * @return void
     */
    protected static function bootTraits()
    {
        $class = static::class;

        foreach (class_uses_recursive($class) as $trait) {
            print("\nTesting that class: $class has method: " . $method = 'boot'.class_basename($trait) . " because of Trait: $trait\n");
            if (method_exists($class, $method = 'boot'.class_basename($trait))) {
                print("Class: $class has method: $method \n");
                try {
                    forward_static_call([$class, $method]);
                } catch (\PHPUnit_Framework_MockObject_BadMethodCallException $e) {
                    print("Class: $class failed calling $method\n");
                    throw $e;
                }
            }
        }
    }
</code></pre>

<p>Gives us this failure:</p>

<pre><code>PHPUnit 5.1.0 by Sebastian Bergmann and contributors.

E                                                                   1 / 1 (100%)
Testing that class: Mock_MyModel_9ee820db has method: bootMyTrait because of Trait: App\MyTrait
Class: Mock_MyModel_9ee820db has method: bootMyTrait
Class: Mock_MyModel_9ee820db failed calling bootMyTrait


Time: 129 ms, Memory: 18.00Mb

There was 1 error:

1) ExampleTest::testTraitBooting
PHPUnit_Framework_MockObject_BadMethodCallException:

mock-bootable-laravel-model-trait/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:326
mock-bootable-laravel-model-trait/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:309
mock-bootable-laravel-model-trait/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:296
mock-bootable-laravel-model-trait/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:277
mock-bootable-laravel-model-trait/tests/ExampleTest.php:16
</code></pre>

<p>I've also tried creating the mock a few different ways. Using <a href="https://github.com/laravel/framework/blob/2a38acf7ee2882d831a3b9a1361a710e70ffa31e/tests/Database/DatabaseSoftDeletingTraitTest.php#L14" title="DatabaseSoftDeletingTraitTest">DatabaseSoftDeletingTraitTest</a> as an example:</p>

<pre><code data-language="php">use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Mockery as m;

class ExampleTest extends TestCase
{
    /**
     * A basic functional test example.
     *
     * @return void
     */
    public function testTraitBooting()
    {
        $mock = m::mock('App\MyModel');
        $mock-&gt;shouldReceive('bootMyTrait')-&gt;once();
    }
}
</code></pre>

<p>But here, bootMyTrait is never called:</p>

<pre><code>PHPUnit 5.1.0 by Sebastian Bergmann and contributors.

E                                                                   1 / 1 (100%)

Time: 149 ms, Memory: 19.25Mb

There was 1 error:

1) ExampleTest::testTraitBooting
Mockery\Exception\InvalidCountException: Method bootMyTrait() from Mockery_0_App_MyModel should be called
 exactly 1 times but called 0 times.

mock-bootable-laravel-model-trait/vendor/mockery/mockery/library/Mockery/CountValidator/Exact.php:37
mock-bootable-laravel-model-trait/vendor/mockery/mockery/library/Mockery/Expectation.php:271
mock-bootable-laravel-model-trait/vendor/mockery/mockery/library/Mockery/ExpectationDirector.php:120
mock-bootable-laravel-model-trait/vendor/mockery/mockery/library/Mockery/Container.php:297
mock-bootable-laravel-model-trait/vendor/mockery/mockery/library/Mockery/Container.php:282
mock-bootable-laravel-model-trait/vendor/mockery/mockery/library/Mockery.php:142
mock-bootable-laravel-model-trait/vendor/laravel/framework/src/Illuminate/Foundation/Testing/TestCase.php:122
</code></pre>

<p>So, I can move the code I'm doing in the boot method to a ServiceProvider, but then I'll need to register each Model that uses the trait. This feels dirty, and using the boot method seems appropriate. So I think I've either hit a bug, or am Mocking the trait-using-model incorrectly. I've looked at <code>getMockForTrait</code> but I also need the mocked instance to extend Eloquent (a few of the trait's methods call eloquent methods)</p>

<p>If anyone sees something I missed, much appreciated</p>

<p><em>Update Apr, 22 (Friday) 2016-04-22 03:28 PM</em></p>

<p>Thanks to <a href="http://stackoverflow.com/a/36771173/647343" title="Marcin">Marcin</a>, we have a solution!</p>

<pre><code data-language="php">&lt;?php

use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Mockery as m;

class ExampleTest extends TestCase
{
    /**
     * A basic functional test example.
     *
     * @return void
     */
    public function testTraitBooting()
    {
        $mock = m::mock('App\MyModel')-&gt;makePartial();
        $mock-&gt;shouldReceive('bootMyTrait')-&gt;once();
        $mock-&gt;__construct();
    }
}

</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Testing UIViewController Transitions with Quick and Swift]]></title>
            <link href="https://www.timbroder.com/2016/01/testing-uiviewcontroller-transitions.html"/>
            <updated>2016-01-31T14:57:00+00:00</updated>
            <id>https://www.timbroder.com/2016/01/testing-uiviewcontroller-transitions.html</id>
            <content type="html"><![CDATA[<p><em>The examples below are using the <a href="https://github.com/Quick/Quick" title="Quick">Quick</a> test framework, but the principals we're going to talk about can be used in any setup.</em></p>

<p>We have some complicated logic further down our user registration flow. I want to make sure that the right UIViewControllers are appearing when they are supposed to. I've been reading a <a href="http://swiftandpainless.com/testing-if-a-view-controller-got-pushed/" title="few">few</a> <a href="https://www.natashatherobot.com/ios-testing-view-controllers-swift/" title="different">different</a> <a href="http://www.iosmike.com/2014/08/unit-testing-viewcontrollers-in-swift.html" title="approaches">approaches</a> on how to handle this. Below is where I've ended up, and I'm pretty happy with it.</p>

<p>For simplicity's sake, I'm going to show how to test if the user has tapped "Login" or "Register" on our opening screen. We can assume we have a LoadingViewController which represents the first screen. On this screens are two buttons, which correspond to these actions:</p>

<pre><code data-language="swift">@IBAction func tapLogin(sender: AnyObject) {
    self.navigationController?.pushViewController(self.storyboard?.instantiateViewControllerWithIdentifier("loginview") as! LoginViewController, animated: true)
}

@IBAction func tapRegister(sender: AnyObject) {
    self.navigationController?.pushViewController(self.storyboard?.instantiateViewControllerWithIdentifier("registerview") as! RegisterViewController, animated: true)
}
</code></pre>

<p>We also have a UINavigationController taking care of the view hierarchy. I also want to use the transitions and IDs already set up in the Storyboard.</p>

<p>Let's start by referencing the UINavigationController and the UIViewController we're going to start with.</p>

<pre><code data-language="swift">class LandingScreenUITests: QuickSpec {
    override func spec() {
        describe("Landing Screen") {

            var viewController: LoadingViewController!
            var navigationController: UINavigationController!


        }
    }
}
</code></pre>

<p>Next, we're going to instantiate the storyboard, both controllers, and push the VC onto the view hierarchy</p>

<pre><code data-language="swift">beforeEach {
    let storyboard = UIStoryboard(name: "Main", bundle: NSBundle(forClass: self.dynamicType))
    viewController = storyboard.instantiateViewControllerWithIdentifier("loadingview") as! LoadingViewController
    navigationController = storyboard.instantiateViewControllerWithIdentifier("navigationcontroller") as! UINavigationController

    navigationController.pushViewController(viewController, animated: false)

    let _ =  viewController.view
}
</code></pre>

<p>Two gotchas to watch out for here:</p>

<ol>
<li>Make sure Main.Storyboard is available in your Test target</li>
<li>Make sure to use the <code>self.dynamicType</code> bundle above</li>
</ol>

<p>Missing either of these may result in a weird casting error:</p>

<pre><code>Could not cast value of type 'MyApp.LoadingViewController' (0x10b9f5e50) to MyAppUITests.LoadingViewController' (0x11f894370).
</code></pre>

<p>Finally, lets call the appropriate methods on our initial UIViewController, and test the type of the UIViewController that has been put on the top of the hierarchy. <em>Note: I use <code>toEventually</code> here to wait for the transition animation</em></p>

<pre><code data-language="swift">describe("User wants to log in") {
    it("taps Login") {
        viewController.tapLogin(self)
        expect(navigationController.visibleViewController).toEventually(beAKindOf(LoginViewController))
    }
}

describe("User wants to register") {
    it("taps Register") {
        viewController.tapRegister(self)
        expect(navigationController.visibleViewController).toEventually(beAKindOf(RegisterViewController))
    }
}
</code></pre>

<p>For reference, here is the whole test class together:</p>

<pre><code data-language="swift">import Foundation
import Quick
import Nimble
@testable import MyApp

class LandingScreenUITests: QuickSpec {
    override func spec() {
        describe("Landing Screen") {

            var viewController: LoadingViewController!
            var navigationController: UINavigationController!

            beforeEach {
                let storyboard = UIStoryboard(name: "Main", bundle: NSBundle(forClass: self.dynamicType))
                viewController = storyboard.instantiateViewControllerWithIdentifier("loadingview") as! LoadingViewController
                navigationController = storyboard.instantiateViewControllerWithIdentifier("navigationcontroller") as! UINavigationController

                navigationController.pushViewController(viewController, animated: false)

                let _ =  viewController.view
            }

            describe("User wants to log in") {
                it("taps Login") {
                    viewController.tapLogin(self)
                    expect(navigationController.visibleViewController).toEventually(beAKindOf(LoginViewController))
                }
            }

            describe("User wants to register") {
                it("taps Register") {
                    viewController.tapRegister(self)
                    expect(navigationController.visibleViewController).toEventually(beAKindOf(RegisterViewController))
                }
            }
        }
    }
}
</code></pre>

<p><em>Many thanks to the blog posts referenced at the top of this post</em></p>
]]></content>
        </entry>
    </feed>